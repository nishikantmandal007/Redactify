version: '3.8'

# Base Docker Compose configuration for CPU-only deployment.
# GPU settings are applied via docker-compose.override.yml.

services:
  redis:
    image: "redis:7-alpine"
    ports:
      # Expose Redis to the host for development/debugging if needed.
      # For production, consider if this needs to be exposed externally.
      - "6379:6379"
    volumes:
      - redis_data:/data # Persist Redis data
    restart: unless-stopped
    networks:
      - redactify_net

  web:
    build:
      context: .. # Project root (parent of 'docker/' directory)
      dockerfile: Redactify/Dockerfile # Points to the CPU Dockerfile
    image: redactify-web-cpu # Optional: define an image name for CPU version
    ports:
      - "5000:5000"
    volumes:
      # Mounts application code for development; for production, code should be built into the image.
      # For a production build, you might remove the Redactify volume mount if images are pre-built.
      - ../Redactify:/app/Redactify
      # Mounts your custom config.yaml from project root into the container.
      - ../config.yaml:/app/config.yaml
      # Example for persistent upload/temp storage (optional, uncomment and adjust host path)
      # - ./data/uploads:/app/upload_files 
      # - ./data/temp_files:/app/temp_files
    depends_on:
      - redis
    environment:
      - REDIS_URL=redis://redis:6379/0 # Connect to the 'redis' service on this Docker network
      - FLASK_ENV=production # Set by Dockerfile, confirmed here
      # - FLASK_APP=Redactify.app # Already set in Dockerfile
      # Add any other necessary environment variables:
      # - REDACTIFY_LOG_LEVEL=INFO
    restart: unless-stopped
    networks:
      - redactify_net

  celery_worker:
    build:
      context: ..
      dockerfile: Redactify/Dockerfile # Uses the same CPU Dockerfile
    image: redactify-celery-cpu # Optional: define an image name for CPU version
    # Default command for a general worker listening to the 'redaction' queue.
    # Adjust queue, concurrency, etc., as needed for your workload.
    command: celery -A Redactify.services.celery_service.celery worker --loglevel=info -Q redaction --concurrency=${CELERY_CONCURRENCY:-2} -E
    volumes:
      - ../Redactify:/app/Redactify
      - ../config.yaml:/app/config.yaml
      # - ./data/uploads:/app/upload_files # Ensure consistency with web service if using host paths
      # - ./data/temp_files:/app/temp_files
    depends_on:
      - redis
    environment:
      - REDIS_URL=redis://redis:6379/0
      - FLASK_ENV=production
      # - C_FORCE_ROOT=true # If Celery needs to run as root (avoid in production if possible)
    restart: unless-stopped
    networks:
      - redactify_net
  
  # To run Celery Beat for scheduled tasks (e.g., cleanup_expired_files):
  # celery_beat:
  #   build:
  #     context: ..
  #     dockerfile: Redactify/Dockerfile
  #   image: redactify-celery-beat-cpu
  #   command: celery -A Redactify.services.celery_service.celery beat --loglevel=info
  #   volumes:
  #     - ../Redactify:/app/Redactify
  #     - ../config.yaml:/app/config.yaml
  #     # - ./data/temp_files:/app/temp_files # If beat needs access to temp files for cleanup logic
  #   depends_on:
  #     - redis
  #   environment:
  #     - REDIS_URL=redis://redis:6379/0
  #     - FLASK_ENV=production
  #   restart: unless-stopped
  #   networks:
  #     - redactify_net

networks:
  redactify_net:
    driver: bridge

volumes:
  redis_data:
    driver: local
